From bd13fb4df702f0d0bed78f1a558a4fbe4d7749c2 Mon Sep 17 00:00:00 2001
From: Marek Vasut <marex@denx.de>
Date: Thu, 19 Jan 2023 21:16:54 +0100
Subject: [PATCH 15/25] net: dwc_eth_qos: Add board_interface_eth_init() for
 i.MX8M Plus

Implement common board_interface_eth_init() and call it from the DWMAC
driver to configure IOMUXC GPR[1] register according to the PHY mode
obtained from DT. This supports all three interface modes supported by
the i.MX8M Plus DWMAC and supersedes current board-side configuration
of the same IOMUX GPR[1] duplicated in the board files.

Upstream-Status: Submitted [https://patchwork.ozlabs.org/project/uboot/patch/20230211214729.478566-9-marex@denx.de/]
Reviewed-by: Ramon Fried <rfried.dev@gmail.com>
Signed-off-by: Marek Vasut <marex@denx.de>
---
Cc: "Ariel D'Alessandro" <ariel.dalessandro@collabora.com>
Cc: "NXP i.MX U-Boot Team" <uboot-imx@nxp.com>
Cc: Andrey Zhizhikin <andrey.zhizhikin@leica-geosystems.com>
Cc: Fabio Estevam <festevam@gmail.com>
Cc: Joe Hershberger <joe.hershberger@ni.com>
Cc: Lukasz Majewski <lukma@denx.de>
Cc: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Cc: Marek Vasut <marex@denx.de>
Cc: Michael Trimarchi <michael@amarulasolutions.com>
Cc: Peng Fan <peng.fan@nxp.com>
Cc: Ramon Fried <rfried.dev@gmail.com>
Cc: Sean Anderson <seanga2@gmail.com>
Cc: Stefano Babic <sbabic@denx.de>
Cc: Tim Harvey <tharvey@gateworks.com>
Cc: Tommaso Merciai <tommaso.merciai@amarulasolutions.com>
Cc: u-boot@lists.denx.de
---
V2: - Add RB from Ramon
    - Handle RGMII_ID/RGMII_RXID/RGMII_TXID just like plain RGMII
V3: Make the function more generic, so it can be shared by eqos and fec
---
 arch/arm/include/asm/arch-imx8m/imx-regs.h |  8 +++-
 arch/arm/mach-imx/imx8m/clock_imx8mm.c     | 53 +++++++++++++++++++++-
 drivers/net/dwc_eth_qos_imx.c              |  4 ++
 3 files changed, 63 insertions(+), 2 deletions(-)

diff --git a/arch/arm/include/asm/arch-imx8m/imx-regs.h b/arch/arm/include/asm/arch-imx8m/imx-regs.h
index 20f4699a12b..88e7f7dc557 100644
--- a/arch/arm/include/asm/arch-imx8m/imx-regs.h
+++ b/arch/arm/include/asm/arch-imx8m/imx-regs.h
@@ -85,7 +85,13 @@
 #define DDRC_IPS_BASE_ADDR(X)	(0x3d400000 + ((X) * 0x2000000))
 #define DDR_CSD1_BASE_ADDR	0x40000000
 
-#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MASK 0x70000
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_RGMII_EN		BIT(21)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_TX_CLK_SEL	BIT(20)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN		BIT(19)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MASK	GENMASK(18, 16)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MII	(0 << 16)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RGMII	(1 << 16)
+#define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RMII	(4 << 16)
 #define FEC_QUIRK_ENET_MAC
 
 #define CAAM_ARB_BASE_ADDR              (0x00100000)
diff --git a/arch/arm/mach-imx/imx8m/clock_imx8mm.c b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
index 494bfbedc8c..fb102ae2059 100644
--- a/arch/arm/mach-imx/imx8m/clock_imx8mm.c
+++ b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
@@ -15,6 +15,7 @@
 #include <errno.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
+#include <phy.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -825,7 +826,7 @@ u32 mxc_get_clock(enum mxc_clock clk)
 	return 0;
 }
 
-#ifdef CONFIG_DWC_ETH_QOS
+#if defined(CONFIG_IMX8MP) && defined(CONFIG_DWC_ETH_QOS)
 int set_clk_eqos(enum enet_freq type)
 {
 	u32 target;
@@ -872,6 +873,46 @@ int set_clk_eqos(enum enet_freq type)
 
 	return 0;
 }
+
+static int imx8mp_eqos_interface_init(struct udevice *dev,
+				      phy_interface_t interface_type)
+{
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+
+	clrbits_le32(&gpr->gpr[1],
+		     IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MASK |
+		     IOMUXC_GPR_GPR1_GPR_ENET_QOS_RGMII_EN |
+		     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_TX_CLK_SEL |
+		     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN);
+
+	switch (interface_type) {
+	case PHY_INTERFACE_MODE_MII:
+		setbits_le32(&gpr->gpr[1],
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN |
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MII);
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		setbits_le32(&gpr->gpr[1],
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_TX_CLK_SEL |
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN |
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RMII);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		setbits_le32(&gpr->gpr[1],
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_RGMII_EN |
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN |
+			     IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RGMII);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
 #endif
 
 #ifdef CONFIG_FEC_MXC
@@ -922,3 +963,13 @@ int set_clk_enet(enum enet_freq type)
 	return 0;
 }
 #endif
+
+int board_interface_eth_init(struct udevice *dev, phy_interface_t interface_type)
+{
+	if (IS_ENABLED(CONFIG_IMX8MP) &&
+	    IS_ENABLED(CONFIG_DWC_ETH_QOS) &&
+	    device_is_compatible(dev, "nxp,imx8mp-dwmac-eqos"))
+		return imx8mp_eqos_interface_init(dev, interface_type);
+
+	return -EINVAL;
+}
diff --git a/drivers/net/dwc_eth_qos_imx.c b/drivers/net/dwc_eth_qos_imx.c
index 962c5373243..60f3f3f5a10 100644
--- a/drivers/net/dwc_eth_qos_imx.c
+++ b/drivers/net/dwc_eth_qos_imx.c
@@ -55,6 +55,10 @@ static int eqos_probe_resources_imx(struct udevice *dev)
 		return -EINVAL;
 	}
 
+	ret = board_interface_eth_init(dev, interface);
+	if (ret)
+		return -EINVAL;
+
 	eqos->max_speed = dev_read_u32_default(dev, "max-speed", 0);
 
 	ret = clk_get_by_name(dev, "stmmaceth", &eqos->clk_master_bus);
-- 
2.39.1

