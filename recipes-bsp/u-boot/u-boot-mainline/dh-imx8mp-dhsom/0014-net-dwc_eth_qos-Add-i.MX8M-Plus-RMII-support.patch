From 0d8905172d7dafdff1d8ce1de39d1acaf52dcaf2 Mon Sep 17 00:00:00 2001
From: Marek Vasut <marex@denx.de>
Date: Thu, 19 Jan 2023 20:57:32 +0100
Subject: [PATCH 14/25] net: dwc_eth_qos: Add i.MX8M Plus RMII support

With DM clock support in place, it is easy to add RMII support into the
MAC driver. The RMII cannot operate at 1000 Mbps and at 100 and 10 Mbps
the clock frequency is 50 MHz and 5 MHz instead of 25 MHz and 2.5 MHz.

The board DT requires the following adjustments to EQoS node:
  phy-mode = "rmii";
  assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_266M>,
  			<&clk IMX8MP_SYS_PLL2_100M>,
  			<&clk IMX8MP_SYS_PLL2_50M>;
  assigned-clock-rates = <0>, <100000000>, <50000000>;

Upstream-Status: Submitted [https://patchwork.ozlabs.org/project/uboot/patch/20230211214729.478566-8-marex@denx.de/]
Reviewed-by: Ramon Fried <rfried.dev@gmail.com>
Signed-off-by: Marek Vasut <marex@denx.de>
---
Cc: "Ariel D'Alessandro" <ariel.dalessandro@collabora.com>
Cc: "NXP i.MX U-Boot Team" <uboot-imx@nxp.com>
Cc: Andrey Zhizhikin <andrey.zhizhikin@leica-geosystems.com>
Cc: Fabio Estevam <festevam@gmail.com>
Cc: Joe Hershberger <joe.hershberger@ni.com>
Cc: Lukasz Majewski <lukma@denx.de>
Cc: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Cc: Marek Vasut <marex@denx.de>
Cc: Michael Trimarchi <michael@amarulasolutions.com>
Cc: Peng Fan <peng.fan@nxp.com>
Cc: Ramon Fried <rfried.dev@gmail.com>
Cc: Sean Anderson <seanga2@gmail.com>
Cc: Stefano Babic <sbabic@denx.de>
Cc: Tim Harvey <tharvey@gateworks.com>
Cc: Tommaso Merciai <tommaso.merciai@amarulasolutions.com>
Cc: u-boot@lists.denx.de
---
V2: Add RB from Ramon
V3: Handle RGMII_*ID variants
---
 drivers/net/dwc_eth_qos_imx.c | 29 ++++++++++++++++++-----------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/net/dwc_eth_qos_imx.c b/drivers/net/dwc_eth_qos_imx.c
index f5f3f2099f0..962c5373243 100644
--- a/drivers/net/dwc_eth_qos_imx.c
+++ b/drivers/net/dwc_eth_qos_imx.c
@@ -179,21 +179,28 @@ static int eqos_set_tx_clk_speed_imx(struct udevice *dev)
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
-	switch (eqos->phy->speed) {
-	case SPEED_1000:
-		rate = 125 * 1000 * 1000;
-		break;
-	case SPEED_100:
-		rate = 25 * 1000 * 1000;
-		break;
-	case SPEED_10:
-		rate = 2.5 * 1000 * 1000;
-		break;
-	default:
+	if (eqos->phy->interface == PHY_INTERFACE_MODE_RMII)
+		rate = 5000;	/* 5000 kHz = 5 MHz */
+	else
+		rate = 2500;	/* 2500 kHz = 2.5 MHz */
+
+	if (eqos->phy->speed == SPEED_1000 &&
+	    (eqos->phy->interface == PHY_INTERFACE_MODE_RGMII ||
+	     eqos->phy->interface == PHY_INTERFACE_MODE_RGMII_ID ||
+	     eqos->phy->interface == PHY_INTERFACE_MODE_RGMII_RXID ||
+	     eqos->phy->interface == PHY_INTERFACE_MODE_RGMII_TXID)) {
+		rate *= 50;	/* Use 50x base rate i.e. 125 MHz */
+	} else if (eqos->phy->speed == SPEED_100) {
+		rate *= 10;	/* Use 10x base rate */
+	} else if (eqos->phy->speed == SPEED_10) {
+		rate *= 1;	/* Use base rate */
+	} else {
 		pr_err("invalid speed %d", eqos->phy->speed);
 		return -EINVAL;
 	}
 
+	rate *= 1000;	/* clk_set_rate() operates in Hz */
+
 	ret = clk_set_rate(&eqos->clk_tx, rate);
 	if (ret < 0) {
 		pr_err("imx (tx_clk, %lu) failed: %d", rate, ret);
-- 
2.39.1

