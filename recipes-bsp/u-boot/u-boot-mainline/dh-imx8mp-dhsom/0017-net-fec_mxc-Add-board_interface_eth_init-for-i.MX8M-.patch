From 2bc28a44742b2cd508ac413b5c9c33ca269cfdc1 Mon Sep 17 00:00:00 2001
From: Marek Vasut <marex@denx.de>
Date: Fri, 10 Feb 2023 16:02:00 +0100
Subject: [PATCH 17/25] net: fec_mxc: Add board_interface_eth_init() for i.MX8M
 Mini/Nano/Plus

Implement common board_interface_eth_init() and call it from the FEC
driver to configure IOMUXC GPR[1] register according to the PHY mode
obtained from DT. This supports all three interface modes supported by
the i.MX8M Mini/Nano/Plus FEC and supersedes the current board-side
configuration of the same IOMUX GPR[1] duplicated in the board files.

Upstream-Status: Submitted [https://patchwork.ozlabs.org/project/uboot/patch/20230211214729.478566-11-marex@denx.de/]
Signed-off-by: Marek Vasut <marex@denx.de>
---
Cc: "Ariel D'Alessandro" <ariel.dalessandro@collabora.com>
Cc: "NXP i.MX U-Boot Team" <uboot-imx@nxp.com>
Cc: Andrey Zhizhikin <andrey.zhizhikin@leica-geosystems.com>
Cc: Fabio Estevam <festevam@gmail.com>
Cc: Joe Hershberger <joe.hershberger@ni.com>
Cc: Lukasz Majewski <lukma@denx.de>
Cc: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Cc: Marek Vasut <marex@denx.de>
Cc: Michael Trimarchi <michael@amarulasolutions.com>
Cc: Peng Fan <peng.fan@nxp.com>
Cc: Ramon Fried <rfried.dev@gmail.com>
Cc: Sean Anderson <seanga2@gmail.com>
Cc: Stefano Babic <sbabic@denx.de>
Cc: Tim Harvey <tharvey@gateworks.com>
Cc: Tommaso Merciai <tommaso.merciai@amarulasolutions.com>
Cc: u-boot@lists.denx.de
---
V3: New patch
---
 arch/arm/include/asm/arch-imx8m/imx-regs.h |  2 +
 arch/arm/mach-imx/imx8m/clock_imx8mm.c     | 48 ++++++++++++++++++++++
 drivers/net/fec_mxc.c                      |  4 ++
 3 files changed, 54 insertions(+)

diff --git a/arch/arm/include/asm/arch-imx8m/imx-regs.h b/arch/arm/include/asm/arch-imx8m/imx-regs.h
index 88e7f7dc557..503e333c822 100644
--- a/arch/arm/include/asm/arch-imx8m/imx-regs.h
+++ b/arch/arm/include/asm/arch-imx8m/imx-regs.h
@@ -85,6 +85,7 @@
 #define DDRC_IPS_BASE_ADDR(X)	(0x3d400000 + ((X) * 0x2000000))
 #define DDR_CSD1_BASE_ADDR	0x40000000
 
+#define IOMUXC_GPR_GPR1_GPR_ENET1_RGMII_EN		BIT(22)
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_RGMII_EN		BIT(21)
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_TX_CLK_SEL	BIT(20)
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_CLK_GEN_EN		BIT(19)
@@ -92,6 +93,7 @@
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MII	(0 << 16)
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RGMII	(1 << 16)
 #define IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_RMII	(4 << 16)
+#define IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL		BIT(13)
 #define FEC_QUIRK_ENET_MAC
 
 #define CAAM_ARB_BASE_ADDR              (0x00100000)
diff --git a/arch/arm/mach-imx/imx8m/clock_imx8mm.c b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
index fb102ae2059..94b15a86acc 100644
--- a/arch/arm/mach-imx/imx8m/clock_imx8mm.c
+++ b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
@@ -962,10 +962,58 @@ int set_clk_enet(enum enet_freq type)
 
 	return 0;
 }
+
+#ifdef CONFIG_IMX8MP
+static int imx8mp_fec_interface_init(struct udevice *dev,
+				     phy_interface_t interface_type,
+				     bool mx8mp)
+{
+	/* i.MX8MP has extra RGMII_EN bit in IOMUXC GPR1 register */
+	const u32 rgmii_en = mx8mp ? IOMUXC_GPR_GPR1_GPR_ENET1_RGMII_EN : 0;
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+
+	clrbits_le32(&gpr->gpr[1],
+		     rgmii_en |
+		     IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL);
+
+	switch (interface_type) {
+	case PHY_INTERFACE_MODE_MII:
+	case PHY_INTERFACE_MODE_RMII:
+		setbits_le32(&gpr->gpr[1], IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		setbits_le32(&gpr->gpr[1], rgmii_en);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
 #endif
 
 int board_interface_eth_init(struct udevice *dev, phy_interface_t interface_type)
 {
+	if (IS_ENABLED(CONFIG_IMX8MM) &&
+	    IS_ENABLED(CONFIG_FEC_MXC) &&
+	    device_is_compatible(dev, "fsl,imx8mm-fec"))
+		return imx8mp_fec_interface_init(dev, interface_type, false);
+
+	if (IS_ENABLED(CONFIG_IMX8MN) &&
+	    IS_ENABLED(CONFIG_FEC_MXC) &&
+	    device_is_compatible(dev, "fsl,imx8mn-fec"))
+		return imx8mp_fec_interface_init(dev, interface_type, false);
+
+	if (IS_ENABLED(CONFIG_IMX8MP) &&
+	    IS_ENABLED(CONFIG_FEC_MXC) &&
+	    device_is_compatible(dev, "fsl,imx8mp-fec"))
+		return imx8mp_fec_interface_init(dev, interface_type, true);
+
 	if (IS_ENABLED(CONFIG_IMX8MP) &&
 	    IS_ENABLED(CONFIG_DWC_ETH_QOS) &&
 	    device_is_compatible(dev, "nxp,imx8mp-dwmac-eqos"))
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index f13784c9326..d564e5eca82 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -1159,6 +1159,10 @@ static int fecmxc_probe(struct udevice *dev)
 	uint32_t start;
 	int ret;
 
+	ret = board_interface_eth_init(dev, pdata->phy_interface);
+	if (ret)
+		return ret;
+
 	if (CONFIG_IS_ENABLED(IMX_MODULE_FUSE)) {
 		if (enet_fused((ulong)priv->eth)) {
 			printf("SoC fuse indicates Ethernet@0x%lx is unavailable.\n", (ulong)priv->eth);
-- 
2.39.1

